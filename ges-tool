#!/usr/bin/env bash
# This script was generated by bashly 1.1.3 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
ges_tool_usage() {
  if [[ -n $long_usage ]]; then
    printf "ges-tool - CLI for GCP GenAI App Builder Enterprise Search.\n"
    echo

  else
    printf "ges-tool - CLI for GCP GenAI App Builder Enterprise Search.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  ges-tool COMMAND\n"
  printf "  ges-tool [COMMAND] --help | -h\n"
  printf "  ges-tool --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Checks for gcloud authentication and installs dependent tools\n" "$(green "init")   "
  printf "  %s   Perform a single search query and outputs results as csv\n" "$(green "search") "
  printf "  %s   Perform a batch search using queries from an external file\n" "$(green "bsearch")"
  printf "  %s   Perform a batch search and verify using an input csv file that outputs to JSON lines.\n" "$(green "verify") "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "$(magenta "--version, -v")"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "$(bold "Environment Variables:")"

    # :environment_variable.usage
    printf "  %s\n" "$(cyan "GCP_PROJECT_NUMBER (required)")"
    printf "    Set your GCP Enterprise Search Project Number (not project id)\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "$(cyan "DATASTORE_NAME (required)")"
    printf "    Data Store name of the format <data_store>_<some_number>\"\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "$(cyan "GCP_ACCESS_TOKEN")"
    printf "    Optional - GCP access-token. To be used if access-token is obtained using\n    third party tool like Vault. If this is not set then  \`gcloud auth\n    print-access-token\` is used to obtain access token.\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  Single search with csv output. Only shows the summary and first document link\n  $ ./ges-tool search \"What is Google's revenue for year ending 2022?\" \n  \n  Single search with table output. Only shows the summary and first document\n  link\n  $ ./ges-tool s \"What is Google's revenue for year ending 2022?\" --format=table\n  \n   Single search with raw json output\n  $ ./ges-tool s \"What is Google's revenue for year ending 2022?\" -f=json \n  \n  Batch search with input file containing search queries and output a csv file\n  with results. Only shows the summary and first document link\n  $ ./ges-tool bsearch test/data/batch_test.txt --format=table \n  \n  Batch search AND verify with input file containing search queries and output a\n  csv file with results.\n  $ ./ges-tool verify test/data/verification_test_with_prompt.csv --format=csv\n"
    echo

  fi
}

# :command.usage
ges_tool_init_usage() {
  if [[ -n $long_usage ]]; then
    printf "ges-tool init - Checks for gcloud authentication and installs dependent tools\n"
    echo

  else
    printf "ges-tool init - Checks for gcloud authentication and installs dependent tools\n"
    echo

  fi

  printf "Alias: i\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  ges-tool init\n"
  printf "  ges-tool init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
ges_tool_search_usage() {
  if [[ -n $long_usage ]]; then
    printf "ges-tool search - Perform a single search query and outputs results as csv\n"
    echo

  else
    printf "ges-tool search - Perform a single search query and outputs results as csv\n"
    echo

  fi

  printf "Alias: s\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  ges-tool search QUERY [OPTIONS]\n"
  printf "  ges-tool search --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--format, -f FORMAT")"
    printf "    format of output.\n"
    printf "    Allowed: csv, table, json\n"
    printf "    Default: csv\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "QUERY")"
    printf "    search query string\n"
    echo

  fi
}

# :command.usage
ges_tool_bsearch_usage() {
  if [[ -n $long_usage ]]; then
    printf "ges-tool bsearch - Perform a batch search using queries from an external file\n"
    echo

  else
    printf "ges-tool bsearch - Perform a batch search using queries from an external file\n"
    echo

  fi

  printf "Alias: b\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  ges-tool bsearch INPUT_FILE [OPTIONS]\n"
  printf "  ges-tool bsearch --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--format, -f FORMAT")"
    printf "    format of output.\n"
    printf "    Allowed: csv, table, json\n"
    printf "    Default: csv\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "INPUT_FILE")"
    printf "    Text file name containing queries. One per line.\n"
    echo

  fi
}

# :command.usage
ges_tool_verify_usage() {
  if [[ -n $long_usage ]]; then
    printf "ges-tool verify - Perform a batch search and verify using an input csv file that outputs to JSON lines.\n"
    echo

  else
    printf "ges-tool verify - Perform a batch search and verify using an input csv file that outputs to JSON lines.\n"
    echo

  fi

  printf "Alias: v\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  ges-tool verify INPUT_FILE [OPTIONS]\n"
  printf "  ges-tool verify --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--format, -f FORMAT")"
    printf "    format of output.\n"
    printf "    Allowed: csv, table, json\n"
    printf "    Default: csv\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "INPUT_FILE")"
    printf "    csv file containing queries and expected results format is -\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "$(bold "Environment Variables:")"

    # :environment_variable.usage
    printf "  %s\n" "$(cyan "PROJECT_ID (required)")"
    printf "    GCP Project where Palm text-bison API is enabled and available\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "$(cyan "LOCATION_ID (required)")"
    printf "    GCP Region to use for the text-bison API is enabled and available\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/call_vertex_ai_search.sh
# shellcheck disable=SC2148
call_vertex_ai_search() {

    command_output=$(curl -s -X POST -H "Authorization: Bearer $token" -H "Content-Type: application/json" "https://discoveryengine.googleapis.com/v1alpha/projects/${GCP_PROJECT_NUMBER}/locations/global/collections/default_collection/dataStores/${DATASTORE_NAME}/servingConfigs/default_search:search" -d '{ "query": "'"${query}"'", "page_size": "5", "offset": 0 , "contentSearchSpec": { "snippetSpec":{"maxSnippetCount": 2}, "summarySpec":{"summaryResultCount": 3}} }')

    error=$(echo "$command_output" | jq '.error.code' )
    if [ "$error" = '401' ]; then
        error_message=$(echo "$command_output" | jq '.error.message' )
        echo "Authentication failed. ErrorCode:$error ErrorMessage:$error_message"
        exit 1
    fi

}

# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/format-output.sh
# shellcheck disable=SC2148
format_output() {
    if [ "$format" = "table" ]; then
        echo "$output" | ./jtbl

    elif [ "$format" == "csv" ]; then
        echo "$output" | ./jtbl -c
    elif [ "$format" == "json" ]; then
        echo "$output"

    fi

}

# :command.command_functions
# :command.function
ges_tool_init_command() {
  # src/init_command.sh
  if [ -f "jtbl" ]; then
    echo "The jbtl tool is already installed."
  else
    # Determine the platform.
    platform=$(uname -s)-$(uname -m)
    # to upper case
    platform_lower=${platform,,}

     # Destination file to save the downloaded content
    file_path=jtbl-1.5.2-"${platform_lower}".tar.gz

    url=https://github.com/kellyjonbrazil/jtbl/releases/download/v1.5.2/jtbl-1.5.2-"${platform_lower}".tar.gz

    # Use curl to download the file
    response_code=$(curl -LO "$url" -w "%{http_code}")

    # Check the HTTP status code
    if [ "$response_code" -eq 200 ]; then
      echo "File $file_path downloaded successfully (HTTP status code: $response_code)."
      echo "The jbtl tool installed."
      # You can further process the downloaded file or display a success message.
    else
      echo "File download failed (HTTP status code: $response_code)."
      echo "The jbtl tool NOT installed. Check you have an internet connection."
      exit 1
      # Handle the error or display an error message.
    fi
    tar -xzf "$file_path"

    rm "$file_path"
  fi
  echo "Checking for gcloud authetication"
  token=$(gcloud auth print-access-token)
  echo "gcloud auth succeeded."

}

# :command.function
ges_tool_search_command() {
  # src/search_command.sh
  querystring=${args[query]}
  format=${args[--format]}
  file=${args[--file]}

  token=${GCP_ACCESS_TOKEN}

  if [ -z "$token" ]; then

      token=$(gcloud auth print-access-token)
  fi

  flag=''

  if [[ $minimal ]]; then
      output=$(curl -s  -X POST -H "Authorization: Bearer $token" -H "Content-Type: application/json" "https://discoveryengine.googleapis.com/v1alpha/projects/${GCP_PROJECT_NUMBER}/locations/global/collections/default_collection/dataStores/${DATASTORE_NAME}/servingConfigs/default_search:search" -d '{ "query": "'"${querystring}"'", "page_size": "5", "offset": 0 , "contentSearchSpec": { "snippetSpec":{"maxSnippetCount": 3}, "summarySpec":{"summaryResultCount": 5} } }')
      use_jtbl=1
  elif  [[ $csv ]]; then
      output=$(curl -s -X POST -H "Authorization: Bearer $token" -H "Content-Type: application/json" "https://discoveryengine.googleapis.com/v1alpha/projects/${GCP_PROJECT_NUMBER}/locations/global/collections/default_collection/dataStores/${DATASTORE_NAME}/servingConfigs/default_search:search" -d '{ "query": "'"${querystring}"'", "page_size": "5", "offset": 0 , "contentSearchSpec": { "snippetSpec":{"maxSnippetCount": 3}, "summarySpec":{"summaryResultCount": 5}} }')
      flag='-c'
      use_jtbl=1
  else
      output=$(curl -s -X POST -H "Authorization: Bearer $token" -H "Content-Type: application/json" "https://discoveryengine.googleapis.com/v1alpha/projects/${GCP_PROJECT_NUMBER}/locations/global/collections/default_collection/dataStores/${DATASTORE_NAME}/servingConfigs/default_search:search" -d '{ "query": "'"${querystring}"'", "page_size": "5", "offset": 0 , "contentSearchSpec": { "snippetSpec":{"maxSnippetCount": 3}, "summarySpec":{"summaryResultCount": 5} } }')
  fi

  if [[ $output ]]; then
      error=$(echo "$output" | jq '.error.code' )
      if [ "$error" = '401' ]; then
          echo "Authentication failed with credentials in GCP_ACCESS_TOKEN"
          exit 1
      else
          if [[ $use_jtbl ]]; then

              echo "$output" | jq  '[{summary: .summary.summaryText, link: .results[0].document.derivedStructData.link}]' | ./jtbl $flag
          else
              echo "$output"

          fi
      fi
  fi

}

# :command.function
ges_tool_bsearch_command() {
  # src/bsearch_command.sh
  format=${args[--format]}
  input_file=${args[input_file]}
  token=${GCP_ACCESS_TOKEN}

  if [ -z "$token" ]; then

      token=$(gcloud auth print-access-token)
  fi

  output=""
  while IFS= read -r line
   do
      if [ -z "$line" ]; then
          continue;
      else
          command_output=""
          query=$line
          call_vertex_ai_search
          summary=$(echo "$command_output" | jq '.summary.summaryText' | sed 's/"//g')
          link_1=$(echo "$command_output" | jq '.results[0].document.derivedStructData.link' | sed 's/"//g' )
          link_2=$(echo "$command_output" | jq '.results[1].document.derivedStructData.link' | sed 's/"//g' )

          link_3=$(echo "$command_output" | jq '.results[2].document.derivedStructData.link' | sed 's/"//g' )

          output+="{\"summary\": \"$summary\", \"link_1\": \"$link_1\", \"link_2\": \"$link_2\", \"link_3\": \"$link_3\"}"$'\n'

      fi
  done < "$input_file"

  format_output

}

# :command.function
ges_tool_verify_command() {
  # src/verify_command.sh
  #inspect_args
  input_file=${args[input_file]}
  format=${args[--format]}
  token=${GCP_ACCESS_TOKEN}

  if [ -z "$token" ]; then

      token=$(gcloud auth print-access-token)
  fi

  # Check if the file exists
  if [ ! -f "$input_file" ]; then
    echo "File not found: $input_file"
    exit 1
  fi

  # Read the CSV file line by line
  read -r header < "$input_file" # Read the first line as header
  column_names=($(echo "$header" | tr ',' '\n')) # Split header into array based on comma delimiter

  # Verify column names or take any actions based on them
  expected_columns=("id" "query" "expected_summary" "expected_document_link_1" "expected_document_link_2") # Define expected column names
  if [ "${#column_names[@]}" -ne "${#expected_columns[@]}" ]; then
    echo "Column count doesn't match!"
    exit 1
  fi

  for ((i = 0; i < ${#expected_columns[@]}; i++)); do
    if [ "${column_names[$i]}" != "${expected_columns[$i]}" ]; then
      echo "Column '${expected_columns[$i]}' not found!"
      exit 1
    fi
  done

  ids=()
  queries=()
  expected_summaries=()
  expected_document_links_1=()
  expected_document_links_2=()

  # Read the rest of the rows and store individual fields in arrays
  while IFS=',' read -r id query expected_summary expected_document_link_1 expected_document_link_2 ; do
    ids+=("$id")
    queries+=("$query")
    expected_summaries+=("$expected_summary")
    expected_document_links_1+=("$expected_document_link_1")
    expected_document_links_2+=("$expected_document_link_2")
  done < <(tail -n +2 "$input_file")

  output=""
  # Display or process the arrays

  for ((i = 0; i < ${#ids[@]}; i++)); do
    #echo "ID: ${ids[$i]}, query: ${queries[$i]}, expected_summary: ${expected_summaries[$i]}, expected_document_link: ${expected_document_links[$i]}"
    # Skip line with empty id field
    if [ -z "${ids[$i]}" ]; then
        continue;
    else
      current_id="${ids[$i]}"
      expected_link_1="${expected_document_links_1[$i]}"
      expected_link_2="${expected_document_links_2[$i]}"
      expected_link_1=$(echo "$expected_link_1" | xargs)
      expected_link_2=$(echo "$expected_link_2" | xargs)
      query=${queries[$i]}
      call_vertex_ai_search
      summary_to_match=$(echo "$command_output" | jq '.summary.summaryText' | sed 's/"//g')
      actual_link_1=$(echo "$command_output" | jq '.results[0].document.derivedStructData.link' | sed 's/"//g' | xargs)
      actual_link_2=$(echo "$command_output" | jq '.results[1].document.derivedStructData.link' | sed 's/"//g' | xargs)

      if [ "$actual_link_1" == "${expected_link_1}" ]; then
          link_1_match="matched"
      else

          link_1_match="not_matched"
      fi

      if [ "$actual_link_2" == "${expected_link_2}" ]; then
          link_2_match="matched"
      else

          link_2_match="not_matched"
      fi

      expected_summary=${expected_summaries[$i]}
      # Verify the summary by calling text-bison
      prompt="You will get two answers to a question, you should determine if they are semantically similar or not.

      examples - answer_1: I was created by X. answer_2: X created me. output:same

      answer_1:There are 52 days in a year. answer_2: A year is fairly long. output:different"
      full_payload=$prompt" Now answer answer_1: $summary_to_match,
          answer_2: $expected_summary
          output:"

      jsonPayload="

      {
              \"instances\": [
                  {
                      \"content\": \"${full_payload}\"
                  }
              ],
              \"parameters\": {
                  \"candidateCount\": 1,
                  \"maxOutputTokens\": 1024,
                  \"temperature\": 0.2
              }
      }"
      #echo "$jsonPayload"

      API_ENDPOINT="${LOCATION_ID}-aiplatform.googleapis.com"
      MODEL_ID="text-bison"

      match_result=$(curl \
      -s \
      -X POST \
      -H "Authorization: Bearer $token" \
      -H "Content-Type: application/json" \
      "https://${API_ENDPOINT}/v1/projects/${PROJECT_ID}/locations/${LOCATION_ID}/publishers/google/models/${MODEL_ID}:predict" -d "$jsonPayload")

      summary_match=$(echo "$match_result" | jq '.predictions[0].content' | sed 's/"//g')

      output+="{\"id\": \"$current_id\", \"actual_summary\": \"$summary_to_match\", \"expected_summary\": \"$expected_summary\", \"summary_match\": \"$summary_match\" , \"expected_link_1\": \"$expected_link_1\"  ,  \"actual_link_1\": \"$actual_link_1\", \"link_1_match\": \"$link_1_match\", \"expected_link_2\": \"$expected_link_2\" ,  \"actual_link_2\": \"$actual_link_2\"  ,\"link_2_match\": \"$link_2_match\"}"$'\n'

    fi
  done

  format_output

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        ges_tool_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  if [[ -z "${GCP_PROJECT_NUMBER:-}" ]]; then
    printf "missing required environment variable: GCP_PROJECT_NUMBER\n" >&2
    exit 1
  fi
  if [[ -z "${DATASTORE_NAME:-}" ]]; then
    printf "missing required environment variable: DATASTORE_NAME\n" >&2
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    init | i)
      action="init"
      shift
      ges_tool_init_parse_requirements "$@"
      shift $#
      ;;

    search | s)
      action="search"
      shift
      ges_tool_search_parse_requirements "$@"
      shift $#
      ;;

    bsearch | b)
      action="bsearch"
      shift
      ges_tool_bsearch_parse_requirements "$@"
      shift $#
      ;;

    verify | v)
      action="verify"
      shift
      ges_tool_verify_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      ges_tool_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
ges_tool_init_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ges_tool_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  if command -v curl >/dev/null 2>&1; then
    deps['curl']="$(command -v curl | head -n1)"
  else
    printf "missing dependency: curl\n" >&2
    exit 1
  fi

  if command -v jq >/dev/null 2>&1; then
    deps['jq']="$(command -v jq | head -n1)"
  else
    printf "missing dependency: jq\n" >&2
    exit 1
  fi

  # :command.command_filter
  action="init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
ges_tool_search_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ges_tool_search_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="search"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --format | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--format']="$2"
          shift
          shift
        else
          printf "%s\n" "--format requires an argument: --format, -f FORMAT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['query']+x} ]]; then

          args['query']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['query']+x} ]]; then
    printf "missing required argument: QUERY\nusage: ges-tool search QUERY [OPTIONS]\n" >&2
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--format']:-} ]] || args['--format']="csv"

  # :command.whitelist_filter
  if [[ ${args['--format']:-} ]] && [[ ! ${args['--format']:-} =~ ^(csv|table|json)$ ]]; then
    printf "%s\n" "--format must be one of: csv, table, json" >&2
    exit 1
  fi

}

# :command.parse_requirements
ges_tool_bsearch_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ges_tool_bsearch_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bsearch"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --format | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--format']="$2"
          shift
          shift
        else
          printf "%s\n" "--format requires an argument: --format, -f FORMAT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['input_file']+x} ]]; then

          args['input_file']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['input_file']+x} ]]; then
    printf "missing required argument: INPUT_FILE\nusage: ges-tool bsearch INPUT_FILE [OPTIONS]\n" >&2
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--format']:-} ]] || args['--format']="csv"

  # :command.whitelist_filter
  if [[ ${args['--format']:-} ]] && [[ ! ${args['--format']:-} =~ ^(csv|table|json)$ ]]; then
    printf "%s\n" "--format must be one of: csv, table, json" >&2
    exit 1
  fi

}

# :command.parse_requirements
ges_tool_verify_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ges_tool_verify_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  if [[ -z "${PROJECT_ID:-}" ]]; then
    printf "missing required environment variable: PROJECT_ID\n" >&2
    exit 1
  fi
  if [[ -z "${LOCATION_ID:-}" ]]; then
    printf "missing required environment variable: LOCATION_ID\n" >&2
    exit 1
  fi

  # :command.command_filter
  action="verify"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --format | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--format']="$2"
          shift
          shift
        else
          printf "%s\n" "--format requires an argument: --format, -f FORMAT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['input_file']+x} ]]; then

          args['input_file']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['input_file']+x} ]]; then
    printf "missing required argument: INPUT_FILE\nusage: ges-tool verify INPUT_FILE [OPTIONS]\n" >&2
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--format']:-} ]] || args['--format']="csv"

  # :command.whitelist_filter
  if [[ ${args['--format']:-} ]] && [[ ! ${args['--format']:-} =~ ^(csv|table|json)$ ]]; then
    printf "%s\n" "--format must be one of: csv, table, json" >&2
    exit 1
  fi

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "init") ges_tool_init_command ;;
    "search") ges_tool_search_command ;;
    "bsearch") ges_tool_bsearch_command ;;
    "verify") ges_tool_verify_command ;;
  esac
}

initialize
run "$@"
